<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iota.lib.cpp: IOTA::API::Extended Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iota.lib.cpp
   </div>
   <div id="projectbrief">IOTA C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>IOTA</b></li><li class="navelem"><b>API</b></li><li class="navelem"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html">Extended</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_o_t_a_1_1_a_p_i_1_1_extended-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IOTA::API::Extended Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for IOTA::API::Extended:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_o_t_a_1_1_a_p_i_1_1_extended.png" usemap="#IOTA::API::Extended_map" alt=""/>
  <map id="IOTA::API::Extended_map" name="IOTA::API::Extended_map">
<area href="class_i_o_t_a_1_1_a_p_i_1_1_core.html" alt="IOTA::API::Core" shape="rect" coords="0,0,125,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adbf8ccbfec9fddd40496b7b185129615"><td class="memItemLeft" align="right" valign="top"><a id="adbf8ccbfec9fddd40496b7b185129615"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Extended</b> (const std::string &amp;host, const unsigned int &amp;port, Crypto::SpongeType cryptoType=Crypto::SpongeType::KERL)</td></tr>
<tr class="separator:adbf8ccbfec9fddd40496b7b185129615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ce22667dbb383ff396c5a37b2b5d82"><td class="memItemLeft" align="right" valign="top"><a id="ae9ce22667dbb383ff396c5a37b2b5d82"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInputs</b> (const std::string &amp;seed, const int32_t &amp;security, const int32_t &amp;start, const int32_t &amp;end, const int64_t &amp;threshold) const</td></tr>
<tr class="separator:ae9ce22667dbb383ff396c5a37b2b5d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad406eec7a28f697248bf1306050c789f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad406eec7a28f697248bf1306050c789f">getBalancesAndFormat</a> (const std::vector&lt; std::string &gt; &amp;addresses, const int64_t &amp;threshold, const int32_t &amp;start, <a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a> stopWatch, const int32_t &amp;security) const</td></tr>
<tr class="separator:ad406eec7a28f697248bf1306050c789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f3436637671d3de6d9c99b86ed8edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a30f3436637671d3de6d9c99b86ed8edc">getNewAddresses</a> (const std::string &amp;seed, const uint32_t &amp;index=0, const int32_t &amp;security=2, bool checksum=false, const int32_t &amp;total=0, bool returnAll=false) const</td></tr>
<tr class="separator:a30f3436637671d3de6d9c99b86ed8edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad027b4e17d5cca2e9bb2eec7575ba55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad027b4e17d5cca2e9bb2eec7575ba55c">traverseBundle</a> (const std::string &amp;trunkTx) const</td></tr>
<tr class="separator:ad027b4e17d5cca2e9bb2eec7575ba55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e1043f0851b36f1caa4a7fc8335c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ae57e1043f0851b36f1caa4a7fc8335c7">traverseBundle</a> (const std::string &amp;trunkTx, std::string bundleHash, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle) const</td></tr>
<tr class="separator:ae57e1043f0851b36f1caa4a7fc8335c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74137fc615af252ddd333d125c841aff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a74137fc615af252ddd333d125c841aff">bundlesFromAddresses</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;addresses, bool inclusionStates) const</td></tr>
<tr class="separator:a74137fc615af252ddd333d125c841aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5216fbcc778269eb5ae2a996fb6fb21b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a5216fbcc778269eb5ae2a996fb6fb21b">findTransactionObjects</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;input) const</td></tr>
<tr class="separator:a5216fbcc778269eb5ae2a996fb6fb21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953c31b14d3a5c597da6561f35cbd335"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a953c31b14d3a5c597da6561f35cbd335">getTransactionsObjects</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:a953c31b14d3a5c597da6561f35cbd335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c729f792d8b7154a810a7e0df7ed3d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a5c729f792d8b7154a810a7e0df7ed3d8">findTransactionObjectsByBundle</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;input) const</td></tr>
<tr class="separator:a5c729f792d8b7154a810a7e0df7ed3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad80dbd20f6efcabe5234fff81bfde6fe">getLatestInclusion</a> (const std::vector&lt; Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699d47d59998dcb5c4c377dd7dfeb9fc"><td class="memItemLeft" align="right" valign="top"><a id="a699d47d59998dcb5c4c377dd7dfeb9fc"></a>
std::vector&lt; Types::Trytes &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>prepareTransfers</b> (const Types::Trytes &amp;seed, int security, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const std::string &amp;remainder, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, bool validateInputs=true) const</td></tr>
<tr class="separator:a699d47d59998dcb5c4c377dd7dfeb9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aae0bbe508888acfe6f97aca3d9e0da86">getBundle</a> (const Types::Trytes &amp;transaction) const</td></tr>
<tr class="separator:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaeca1333d27be96799fbdfdd60292ff"><td class="memItemLeft" align="right" valign="top"><a id="aaaeca1333d27be96799fbdfdd60292ff"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transfers.html">Responses::GetTransfers</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTransfers</b> (const Types::Trytes &amp;seed, int security, int start, int end, bool inclusionStates) const</td></tr>
<tr class="separator:aaaeca1333d27be96799fbdfdd60292ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce339b570682f2c559abf35fb57388b"><td class="memItemLeft" align="right" valign="top"><a id="a0ce339b570682f2c559abf35fb57388b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>replayTransfer</b> () const</td></tr>
<tr class="separator:a0ce339b570682f2c559abf35fb57388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2687ef56ef0340cd21be97f4d359f8"><td class="memItemLeft" align="right" valign="top"><a id="a9e2687ef56ef0340cd21be97f4d359f8"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_send_transfer.html">Responses::SendTransfer</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sendTransfer</b> (const Types::Trytes &amp;seed, int security, int depth, int minWeightMagnitude, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, const Types::Trytes &amp;address) const</td></tr>
<tr class="separator:a9e2687ef56ef0340cd21be97f4d359f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1d2f616a5fa494dfaedf4891f26fb3"><td class="memItemLeft" align="right" valign="top"><a id="a0e1d2f616a5fa494dfaedf4891f26fb3"></a>
std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>sendTrytes</b> (const std::vector&lt; Types::Trytes &gt; &amp;trytes, const unsigned int &amp;depth, const unsigned int &amp;minWeightMagnitude) const</td></tr>
<tr class="separator:a0e1d2f616a5fa494dfaedf4891f26fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bb15cf7263511e76c6a07ff9772dcb"><td class="memItemLeft" align="right" valign="top"><a id="a83bb15cf7263511e76c6a07ff9772dcb"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_store_transactions.html">Responses::StoreTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>broadcastAndStore</b> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:a83bb15cf7263511e76c6a07ff9772dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaa343b818b96bac952af0064f627ae"><td class="memItemLeft" align="right" valign="top"><a id="afeaa343b818b96bac952af0064f627ae"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findTransactionsByAddresses</b> (const std::vector&lt; Types::Trytes &gt; &amp;addresses) const</td></tr>
<tr class="separator:afeaa343b818b96bac952af0064f627ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500dd6a23e655c7dae924235c1deeb25"><td class="memItemLeft" align="right" valign="top"><a id="a500dd6a23e655c7dae924235c1deeb25"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findTransactionsByDigests</b> (const std::vector&lt; Types::Trytes &gt; &amp;digests) const</td></tr>
<tr class="separator:a500dd6a23e655c7dae924235c1deeb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93356e4fafc265bb4e3974c9ed74f521"><td class="memItemLeft" align="right" valign="top"><a id="a93356e4fafc265bb4e3974c9ed74f521"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findTransactionsByApprovees</b> (const std::vector&lt; Types::Trytes &gt; &amp;approvees) const</td></tr>
<tr class="separator:a93356e4fafc265bb4e3974c9ed74f521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memItemLeft" align="right" valign="top"><a id="a51c3e80e5cd620fbeaf43a854b68a674"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findTransactionsByBundles</b> (const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6e65fa262066ec1fd22c948abdc357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#afd6e65fa262066ec1fd22c948abdc357">getAccountData</a> (const Types::Trytes &amp;seed, int security, int index, bool checksum, int total, bool returnAll, int start, int end, bool inclusionStates, long threshold) const</td></tr>
<tr class="separator:afd6e65fa262066ec1fd22c948abdc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32816e9f2656c71080a841752f52e97e"><td class="memItemLeft" align="right" valign="top">const Types::Trytes &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a32816e9f2656c71080a841752f52e97e">findTailTransactionHash</a> (const Types::Trytes &amp;hash) const</td></tr>
<tr class="separator:a32816e9f2656c71080a841752f52e97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6778a71eceba8c6fb202c6f2362b9804"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a6778a71eceba8c6fb202c6f2362b9804">addRemainder</a> (const Types::Trytes &amp;seed, const unsigned int &amp;security, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle, const std::string &amp;tag, const long &amp;totalValue, const Types::Trytes &amp;remainderAddress, const std::vector&lt; std::string &gt; &amp;signatureFragments) const</td></tr>
<tr class="separator:a6778a71eceba8c6fb202c6f2362b9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489a5b783b9e585e948548b32a24fdf3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a489a5b783b9e585e948548b32a24fdf3">replayBundle</a> (const Types::Trytes &amp;transaction, int depth, int minWeightMagnitude)</td></tr>
<tr class="separator:a489a5b783b9e585e948548b32a24fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c237db6d1ccff2417613496a651bc9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad5c237db6d1ccff2417613496a651bc9">initiateTransfer</a> (int securitySum, const Types::Trytes &amp;inputAddress, const Types::Trytes &amp;remainderAddress, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers) const</td></tr>
<tr class="separator:ad5c237db6d1ccff2417613496a651bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html">IOTA::API::Core</a></td></tr>
<tr class="memitem:a176fcfa7e9dffd5926988bc4235384e9 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a176fcfa7e9dffd5926988bc4235384e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Core</b> (const std::string &amp;host, const unsigned int &amp;port)</td></tr>
<tr class="separator:a176fcfa7e9dffd5926988bc4235384e9 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="aa9d616c9db7893159f16ec1b0356927f"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_node_info.html">Responses::GetNodeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNodeInfo</b> () const</td></tr>
<tr class="separator:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ab23af5efc04e5a04daf7c19014eb0d0b"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_neighbors.html">Responses::GetNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getNeighbors</b> () const</td></tr>
<tr class="separator:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a367bd6329e56491bdb624c083a1b0902"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_add_neighbors.html">Responses::AddNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>addNeighbors</b> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a1420b7aa62e8f87bb844063efab9a8c7"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_remove_neighbors.html">Responses::RemoveNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><b>removeNeighbors</b> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="add317bef9e8d4f2e4eaec3e4b5c7e205"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_tips.html">Responses::GetTips</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTips</b> () const</td></tr>
<tr class="separator:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356e9a9d498fce9eaf9d6f4991dfcae inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ae356e9a9d498fce9eaf9d6f4991dfcae"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>findTransactions</b> (const std::vector&lt; Types::Trytes &gt; &amp;addresses, const std::vector&lt; Types::Trytes &gt; &amp;digests, const std::vector&lt; Types::Trytes &gt; &amp;approvees, const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:ae356e9a9d498fce9eaf9d6f4991dfcae inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d2acf1af8a1a7e609e4f8eef3bfb92 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ad1d2acf1af8a1a7e609e4f8eef3bfb92"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_trytes.html">Responses::GetTrytes</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTrytes</b> (const std::vector&lt; std::string &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad1d2acf1af8a1a7e609e4f8eef3bfb92 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa291ad5046e3cd8ef3cf2dea0cbeb6ed inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="aa291ad5046e3cd8ef3cf2dea0cbeb6ed"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInclusionStates</b> (const std::vector&lt; std::string &gt; &amp;transactions, const std::vector&lt; std::string &gt; &amp;tips) const</td></tr>
<tr class="separator:aa291ad5046e3cd8ef3cf2dea0cbeb6ed inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc7b10edc028e73436102114c9e066f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="a0fc7b10edc028e73436102114c9e066f"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances.html">Responses::GetBalances</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBalances</b> (const std::vector&lt; std::string &gt; &amp;addresses, const int &amp;threshold) const</td></tr>
<tr class="separator:a0fc7b10edc028e73436102114c9e066f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ad2fe78e987cc4b0ca292b35c733da4e8"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transactions_to_approve.html">Responses::GetTransactionsToApprove</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTransactionsToApprove</b> (const int &amp;depth) const</td></tr>
<tr class="separator:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe515fe27b78ebec9b92a6a65fbf577 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="afbe515fe27b78ebec9b92a6a65fbf577"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_attach_to_tangle.html">Responses::AttachToTangle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>attachToTangle</b> (const std::string &amp;trunkTransaction, const std::string &amp;branchTransaction, const int &amp;minWeightMagnitude, const std::vector&lt; std::string &gt; &amp;trytes) const</td></tr>
<tr class="separator:afbe515fe27b78ebec9b92a6a65fbf577 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc1fbe9ca4627569bb0a0d07c2620cf inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="acfc1fbe9ca4627569bb0a0d07c2620cf"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_interrupt_attaching_to_tangle.html">Responses::InterruptAttachingToTangle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>interruptAttachingToTangle</b> () const</td></tr>
<tr class="separator:acfc1fbe9ca4627569bb0a0d07c2620cf inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac195a72dba8e6df146a98c6e843ae30a inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="ac195a72dba8e6df146a98c6e843ae30a"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_broadcast_transactions.html">Responses::BroadcastTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>broadcastTransactions</b> (const std::vector&lt; std::string &gt; &amp;trytes) const</td></tr>
<tr class="separator:ac195a72dba8e6df146a98c6e843ae30a inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff98df75ec1dd590090e7b1e89b37a13 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a id="aff98df75ec1dd590090e7b1e89b37a13"></a>
<a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_store_transactions.html">Responses::StoreTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>storeTransactions</b> (const std::vector&lt; std::string &gt; &amp;trytes) const</td></tr>
<tr class="separator:aff98df75ec1dd590090e7b1e89b37a13 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6778a71eceba8c6fb202c6f2362b9804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6778a71eceba8c6fb202c6f2362b9804">&#9670;&nbsp;</a></span>addRemainder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; IOTA::API::Extended::addRemainder </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long &amp;&#160;</td>
          <td class="paramname"><em>totalValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>signatureFragments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">inputs</td><td>List of inputs used for funding the transfer. </td></tr>
    <tr><td class="paramname">bundle</td><td>To be populated. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">totalValue</td><td>The total value. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to. </td></tr>
    <tr><td class="paramname">signatureFragments</td><td>The signature fragments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74137fc615af252ddd333d125c841aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74137fc615af252ddd333d125c841aff">&#9670;&nbsp;</a></span>bundlesFromAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &gt; IOTA::API::Extended::bundlesFromAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function to get the formatted bundles of a list of addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>List of addresses. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bundles </dd></dl>
<p>find transactions for addresses</p>
<p>filter tail/non tail transactions</p>
<p>find transactions for bundles of non tail transactions TODO: this will maybe re-query some tail transactions we already got (and we do filter that out in the next for loop) we maybe can filter the bundle list passed to findTransactionObjectsByBundle by restructuring the previous loop</p>
<p>add tail transactions found with findTransactionObjectsByBundle</p>
<p>TODO: was done in parallel in java lib, do we need to or performance are fine in cpp? </p>

</div>
</div>
<a id="a32816e9f2656c71080a841752f52e97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32816e9f2656c71080a841752f52e97e">&#9670;&nbsp;</a></span>findTailTransactionHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Types::Trytes &amp; IOTA::API::Extended::findTailTransactionHash </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of a transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash of the tail transaction of the bundle to which the input trx belongs. </dd></dl>

</div>
</div>
<a id="a5216fbcc778269eb5ae2a996fb6fb21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5216fbcc778269eb5ae2a996fb6fb21b">&#9670;&nbsp;</a></span>findTransactionObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::findTransactionObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function for findTransactions, getTrytes and transactionObjects. Returns the transactionObject of a transaction hash. The input can be a valid findTransactions input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>
<p>get the transaction objects of the transactions </p>

</div>
</div>
<a id="a5c729f792d8b7154a810a7e0df7ed3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c729f792d8b7154a810a7e0df7ed3d8">&#9670;&nbsp;</a></span>findTransactionObjectsByBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::findTransactionObjectsByBundle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as findTransactionObjects, but based on bundle hash</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Bundle hashes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>

</div>
</div>
<a id="afd6e65fa262066ec1fd22c948abdc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6e65fa262066ec1fd22c948abdc357">&#9670;&nbsp;</a></span>getAccountData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a> IOTA::API::Extended::getAccountData </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to getTransfers, just that it returns additional account data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The Security level of private key / seed. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. </td></tr>
    <tr><td class="paramname">checksum</td><td>Adds 9-tryte address checksum. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null). </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad406eec7a28f697248bf1306050c789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad406eec7a28f697248bf1306050c789f">&#9670;&nbsp;</a></span>getBalancesAndFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a> IOTA::API::Extended::getBalancesAndFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a>&#160;</td>
          <td class="paramname"><em>stopWatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the balances and formats the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>The addresses. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">stopWatch</td><td>the stopwatch. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inputs object. </dd></dl>
<p>retrieve balances for all given addresses</p>
<p>retrieve balance for given address</p>
<p>skip if no balance</p>
<p>Add input to result and increase totalBalance of all aggregated inputs</p>
<p>TODO: is this break necessary? (that's the logic of the reference java client) threshold is defined as minimum balance expected, but here we stop the process whenever threshold is reached (if different from 0) so is it an expected behavior? If so, why so? Maybe we will get more clues further during the development of other API </p>

</div>
</div>
<a id="aae0bbe508888acfe6f97aca3d9e0da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0bbe508888acfe6f97aca3d9e0da86">&#9670;&nbsp;</a></span>getBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a> IOTA::API::Extended::getBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get bundle hash for transaction</p>
<p>init curl</p>
<p>sums up transaction values</p>
<p>Absorb bundle hash + value + timestamp + lastIndex + currentIndex trytes.</p>
<p>if transaction has some value, we can processs next transactions</p>
<p>Find the subsequent txs with the remaining signature fragment</p>
<p>Check for total sum, if not equal 0 return error</p>
<p>Check if bundle hash is the same as returned by tx object</p>
<p>Last tx in the bundle should have currentIndex == lastIndex</p>
<p>Validate the signatures </p>

</div>
</div>
<a id="ad80dbd20f6efcabe5234fff81bfde6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80dbd20f6efcabe5234fff81bfde6fe">&#9670;&nbsp;</a></span>getLatestInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a> IOTA::API::Extended::getLatestInclusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function for getNodeInfo and getInclusionStates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>The hashes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inclusion state. </dd></dl>

</div>
</div>
<a id="a30f3436637671d3de6d9c99b86ed8edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f3436637671d3de6d9c99b86ed8edc">&#9670;&nbsp;</a></span>getNewAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a> IOTA::API::Extended::getNewAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checksum</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>total</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new address from a seed and returns the remainderAddress. This is either done deterministically, or by providing the index of the new remainderAddress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>Security level to be used for the private key / address. Can be 1, 2 or 3. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. </td></tr>
    <tr><td class="paramname">checksum</td><td>Adds 9-tryte address checksum. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of strings with the specifed number of addresses. </dd></dl>

</div>
</div>
<a id="a953c31b14d3a5c597da6561f35cbd335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953c31b14d3a5c597da6561f35cbd335">&#9670;&nbsp;</a></span>getTransactionsObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::getTransactionsObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function for getTrytes and transactionObjects. Gets the trytes and transaction object from a list of transaction hashes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>The hashes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transaction objects. </dd></dl>
<p>get trytes forhashes</p>
<p>build response </p>

</div>
</div>
<a id="ad5c237db6d1ccff2417613496a651bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c237db6d1ccff2417613496a651bc9">&#9670;&nbsp;</a></span>initiateTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt; IOTA::API::Extended::initiateTransfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>securitySum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>inputAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares transfer by generating the bundle with the corresponding cosigner transactions. Does not contain signatures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">securitySum</td><td>The sum of security levels used by all co-signers. </td></tr>
    <tr><td class="paramname">inputAddress</td><td>Array of input addresses as well as the securitySum. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>Has to be generated by the cosigners before initiating the transfer, can be null if fully spent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bundle of transaction objects. </dd></dl>
<p>If message or tag is not supplied, provide it Also remove the checksum of the address if it's there</p>
<p>validate input address</p>
<p>Create a new bundle</p>
<p>Iterate over all transfers, get totalValue and prepare the signatureFragments, message and tag</p>
<p>If message longer than 2187 trytes, increase signatureMessageLength (add 2nd transaction)</p>
<p>Get total length, message / maxLength (MaxTrxMsgLength trytes)</p>
<p>copy msg</p>
<p>While there is still a message, copy it</p>
<p>Else, get single fragment with MaxTrxMsgLength of 9's trytes</p>
<p>get current timestamp in seconds</p>
<p>If no tag defined, get 27 tryte tag.</p>
<p>Pad for required TagLength tryte length</p>
<p>Add first entry to the bundle</p>
<p>Sum up total value</p>
<p>Get inputs if we are sending tokens</p>
<p>Add input as bundle entry Only a single entry, signatures will be added later</p>
<p>Return not enough balance error</p>
<p>If there is a remainder value Add extra output to send remaining funds to </p>

</div>
</div>
<a id="a489a5b783b9e585e948548b32a24fdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489a5b783b9e585e948548b32a24fdf3">&#9670;&nbsp;</a></span>replayBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a> IOTA::API::Extended::replayBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replays a transfer by doing Proof of Work again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>The transaction. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Analyzed Transaction objects. </dd></dl>

</div>
</div>
<a id="ad027b4e17d5cca2e9bb2eec7575ba55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad027b4e17d5cca2e9bb2eec7575ba55c">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>

</div>
</div>
<a id="ae57e1043f0851b36f1caa4a7fc8335c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e1043f0851b36f1caa4a7fc8335c7">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>bundleHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle. </td></tr>
    <tr><td class="paramname">bundleHash</td><td>The bundle hashe. </td></tr>
    <tr><td class="paramname">bundle</td><td>Bundle to be populated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>
<p>get trytes for transaction</p>
<p>get transaction itself </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/iota/api/<a class="el" href="extended_8hpp_source.html">extended.hpp</a></li>
<li>source/api/extended.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
