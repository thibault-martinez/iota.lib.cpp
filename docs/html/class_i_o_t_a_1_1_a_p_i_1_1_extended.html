<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iota.lib.cpp: IOTA::API::Extended Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iota.lib.cpp
   </div>
   <div id="projectbrief">IOTA C++ Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>IOTA</b></li><li class="navelem"><b>API</b></li><li class="navelem"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html">Extended</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_i_o_t_a_1_1_a_p_i_1_1_extended-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IOTA::API::Extended Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="extended_8hpp_source.html">extended.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IOTA::API::Extended:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_o_t_a_1_1_a_p_i_1_1_extended.png" usemap="#IOTA::API::Extended_map" alt=""/>
  <map id="IOTA::API::Extended_map" name="IOTA::API::Extended_map">
<area href="class_i_o_t_a_1_1_a_p_i_1_1_core.html" alt="IOTA::API::Core" shape="rect" coords="0,0,125,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24292e0b13d2bfe35584f733c322b8c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a24292e0b13d2bfe35584f733c322b8c9">Extended</a> (const std::string &amp;host, const uint16_t &amp;port, bool localPow=true, int timeout=60, Crypto::SpongeType cryptoType=Crypto::SpongeType::KERL)</td></tr>
<tr class="separator:a24292e0b13d2bfe35584f733c322b8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae292873ec0cd8936d28e7ffe95cb6c83"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ae292873ec0cd8936d28e7ffe95cb6c83">~Extended</a> ()=default</td></tr>
<tr class="separator:ae292873ec0cd8936d28e7ffe95cb6c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d756839d245fe54c0be7f20b3bf1121"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a2d756839d245fe54c0be7f20b3bf1121">getInputs</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, const int32_t &amp;start, const int32_t &amp;end, const int32_t &amp;security, const int64_t &amp;threshold) const</td></tr>
<tr class="separator:a2d756839d245fe54c0be7f20b3bf1121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ab589f43b642bb197b5f689dde045d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a93ab589f43b642bb197b5f689dde045d">getBalancesAndFormat</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses, const int64_t &amp;threshold, const int32_t &amp;start, const int32_t &amp;security, const <a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a> &amp;stopWatch={}) const</td></tr>
<tr class="separator:a93ab589f43b642bb197b5f689dde045d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea9ef613cd8f744d3253c8657ffc8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#af9ea9ef613cd8f744d3253c8657ffc8c">getNewAddresses</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, const uint32_t &amp;index=0, const int32_t &amp;security=2, const int32_t &amp;total=0, bool returnAll=false) const</td></tr>
<tr class="separator:af9ea9ef613cd8f744d3253c8657ffc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5c4d33e956c0d76f98aa5a7a1c6f8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a7b5c4d33e956c0d76f98aa5a7a1c6f8f">traverseBundle</a> (const Types::Trytes &amp;trunkTx) const</td></tr>
<tr class="separator:a7b5c4d33e956c0d76f98aa5a7a1c6f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395484ad3ff8c373adb8c981b4f79cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a395484ad3ff8c373adb8c981b4f79cd3">traverseBundle</a> (const Types::Trytes &amp;trunkTx, Types::Trytes bundleHash, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle) const</td></tr>
<tr class="separator:a395484ad3ff8c373adb8c981b4f79cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c0d93b663159c9aeadce499279dd2c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aa4c0d93b663159c9aeadce499279dd2c">bundlesFromAddresses</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses, bool inclusionStates) const</td></tr>
<tr class="separator:aa4c0d93b663159c9aeadce499279dd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4801d5265fa22b702a6c5061073e741a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a4801d5265fa22b702a6c5061073e741a">findTransactionObjects</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses) const</td></tr>
<tr class="separator:a4801d5265fa22b702a6c5061073e741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bf1f658dea8469758c76375a3063f9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#af1bf1f658dea8469758c76375a3063f9">getTransactionsObjects</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;trx_hashes) const</td></tr>
<tr class="separator:af1bf1f658dea8469758c76375a3063f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29595b796aadfef15e95c7e3105b7254"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a29595b796aadfef15e95c7e3105b7254">findTransactionObjectsByBundle</a> (const std::vector&lt; IOTA::Types::Trytes &gt; &amp;input) const</td></tr>
<tr class="separator:a29595b796aadfef15e95c7e3105b7254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#ad80dbd20f6efcabe5234fff81bfde6fe">getLatestInclusion</a> (const std::vector&lt; Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad80dbd20f6efcabe5234fff81bfde6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76135229fb4521f9921374c93523de57"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Types::Trytes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a76135229fb4521f9921374c93523de57">prepareTransfers</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, int security, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;remainder, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, bool validateInputs=true) const</td></tr>
<tr class="separator:a76135229fb4521f9921374c93523de57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aae0bbe508888acfe6f97aca3d9e0da86">getBundle</a> (const Types::Trytes &amp;transaction) const</td></tr>
<tr class="separator:aae0bbe508888acfe6f97aca3d9e0da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f408547f1e309afd1f27297b54e61d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transfers.html">Responses::GetTransfers</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a6f408547f1e309afd1f27297b54e61d4">getTransfers</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, int start, int end, int security, bool inclusionStates) const</td></tr>
<tr class="separator:a6f408547f1e309afd1f27297b54e61d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821080d858d7d982cc169411c3611ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_send_transfer.html">Responses::SendTransfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a821080d858d7d982cc169411c3611ccc">sendTransfer</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, int security, int depth, int minWeightMagnitude, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;address) const</td></tr>
<tr class="separator:a821080d858d7d982cc169411c3611ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a127282d2f4d9e8dff38a74eb70d67"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a58a127282d2f4d9e8dff38a74eb70d67">sendTrytes</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes, const unsigned int &amp;depth, const unsigned int &amp;minWeightMagnitude) const</td></tr>
<tr class="separator:a58a127282d2f4d9e8dff38a74eb70d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84894cbaa3fa57252a8a34a75e0d7ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#aa84894cbaa3fa57252a8a34a75e0d7ab">broadcastAndStore</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:aa84894cbaa3fa57252a8a34a75e0d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1386ef7e950e762742dca102cc09e3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a1386ef7e950e762742dca102cc09e3b9">findTransactionsByAddresses</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses) const</td></tr>
<tr class="separator:a1386ef7e950e762742dca102cc09e3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f943cddf154a2d7937f2db5f86ee56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a72f943cddf154a2d7937f2db5f86ee56">findTransactionsByTags</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_tag.html">Models::Tag</a> &gt; &amp;tags) const</td></tr>
<tr class="separator:a72f943cddf154a2d7937f2db5f86ee56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93356e4fafc265bb4e3974c9ed74f521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a93356e4fafc265bb4e3974c9ed74f521">findTransactionsByApprovees</a> (const std::vector&lt; Types::Trytes &gt; &amp;approvees) const</td></tr>
<tr class="separator:a93356e4fafc265bb4e3974c9ed74f521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a51c3e80e5cd620fbeaf43a854b68a674">findTransactionsByBundles</a> (const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:a51c3e80e5cd620fbeaf43a854b68a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb1bd334481e0c17457c4f15950168"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a64bb1bd334481e0c17457c4f15950168">getAccountData</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, int index, int security, int total, bool returnAll, int start, int end, bool inclusionStates, long threshold) const</td></tr>
<tr class="separator:a64bb1bd334481e0c17457c4f15950168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84744f17dd0c8f5b8b26062aff52d473"><td class="memItemLeft" align="right" valign="top">Types::Trytes&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a84744f17dd0c8f5b8b26062aff52d473">findTailTransactionHash</a> (const Types::Trytes &amp;hash) const</td></tr>
<tr class="separator:a84744f17dd0c8f5b8b26062aff52d473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622593ef0532f94e695bcb88b3f9fc7e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Types::Trytes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a622593ef0532f94e695bcb88b3f9fc7e">addRemainder</a> (const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;seed, const unsigned int &amp;security, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;inputs, <a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;bundle, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_tag.html">Models::Tag</a> &amp;tag, const int64_t &amp;totalValue, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;remainderAddress, const std::vector&lt; Types::Trytes &gt; &amp;signatureFragments) const</td></tr>
<tr class="separator:a622593ef0532f94e695bcb88b3f9fc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba2e1ee23eea14dd2aa8a1f4b5ee653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a1ba2e1ee23eea14dd2aa8a1f4b5ee653">replayBundle</a> (const Types::Trytes &amp;transaction, int depth, int minWeightMagnitude) const</td></tr>
<tr class="separator:a1ba2e1ee23eea14dd2aa8a1f4b5ee653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8426a72125a659eb1af9431ec0bd1d39"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html#a8426a72125a659eb1af9431ec0bd1d39">initiateTransfer</a> (int securitySum, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;inputAddress, const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;remainderAddress, std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;transfers) const</td></tr>
<tr class="separator:a8426a72125a659eb1af9431ec0bd1d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html">IOTA::API::Core</a></td></tr>
<tr class="memitem:adf36a2dd109c5ccc0d31c58bde7743ca inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#adf36a2dd109c5ccc0d31c58bde7743ca">Core</a> (const std::string &amp;host, const uint16_t &amp;port, bool localPow=true, int timeout=60)</td></tr>
<tr class="separator:adf36a2dd109c5ccc0d31c58bde7743ca inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c19113fb5e0f7a0a74b992e955ffce inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a77c19113fb5e0f7a0a74b992e955ffce">~Core</a> ()=default</td></tr>
<tr class="separator:a77c19113fb5e0f7a0a74b992e955ffce inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_node_info.html">Responses::GetNodeInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#aa9d616c9db7893159f16ec1b0356927f">getNodeInfo</a> () const</td></tr>
<tr class="separator:aa9d616c9db7893159f16ec1b0356927f inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_neighbors.html">Responses::GetNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#ab23af5efc04e5a04daf7c19014eb0d0b">getNeighbors</a> () const</td></tr>
<tr class="separator:ab23af5efc04e5a04daf7c19014eb0d0b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_add_neighbors.html">Responses::AddNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a367bd6329e56491bdb624c083a1b0902">addNeighbors</a> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a367bd6329e56491bdb624c083a1b0902 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_remove_neighbors.html">Responses::RemoveNeighbors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a1420b7aa62e8f87bb844063efab9a8c7">removeNeighbors</a> (const std::vector&lt; std::string &gt; &amp;uris) const</td></tr>
<tr class="separator:a1420b7aa62e8f87bb844063efab9a8c7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_tips.html">Responses::GetTips</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#add317bef9e8d4f2e4eaec3e4b5c7e205">getTips</a> () const</td></tr>
<tr class="separator:add317bef9e8d4f2e4eaec3e4b5c7e205 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c7dd5123f6175bd81472bc02e180e7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#aa7c7dd5123f6175bd81472bc02e180e7">findTransactions</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses, const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_tag.html">Models::Tag</a> &gt; &amp;tags, const std::vector&lt; Types::Trytes &gt; &amp;approvees, const std::vector&lt; Types::Trytes &gt; &amp;bundles) const</td></tr>
<tr class="separator:aa7c7dd5123f6175bd81472bc02e180e7 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f5cdbb41044f62c491f2dab06bf52b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_trytes.html">Responses::GetTrytes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#ad6f5cdbb41044f62c491f2dab06bf52b">getTrytes</a> (const std::vector&lt; Types::Trytes &gt; &amp;hashes) const</td></tr>
<tr class="separator:ad6f5cdbb41044f62c491f2dab06bf52b inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fa48b2ebe2fff583b65feb791804a6 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#ae0fa48b2ebe2fff583b65feb791804a6">getInclusionStates</a> (const std::vector&lt; Types::Trytes &gt; &amp;transactions, const std::vector&lt; Types::Trytes &gt; &amp;tips) const</td></tr>
<tr class="separator:ae0fa48b2ebe2fff583b65feb791804a6 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec304165784396d8e8b52eca5189245c inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances.html">Responses::GetBalances</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#aec304165784396d8e8b52eca5189245c">getBalances</a> (const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;addresses, const int &amp;threshold) const</td></tr>
<tr class="separator:aec304165784396d8e8b52eca5189245c inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transactions_to_approve.html">Responses::GetTransactionsToApprove</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#ad2fe78e987cc4b0ca292b35c733da4e8">getTransactionsToApprove</a> (const int &amp;depth) const</td></tr>
<tr class="separator:ad2fe78e987cc4b0ca292b35c733da4e8 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb57e8a6ba98be6947b008edcb4f8a4 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_attach_to_tangle.html">Responses::AttachToTangle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#addb57e8a6ba98be6947b008edcb4f8a4">attachToTangle</a> (const Types::Trytes &amp;trunkTransaction, const Types::Trytes &amp;branchTransaction, const int &amp;minWeightMagnitude, const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:addb57e8a6ba98be6947b008edcb4f8a4 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1779df873b2877aa4ae87421ff947c72 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a1779df873b2877aa4ae87421ff947c72">interruptAttachingToTangle</a> () const</td></tr>
<tr class="separator:a1779df873b2877aa4ae87421ff947c72 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9605f23dae0920d286d208a5ad806e inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a0f9605f23dae0920d286d208a5ad806e">broadcastTransactions</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:a0f9605f23dae0920d286d208a5ad806e inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc2694189aacb9b1f55a1664661b84 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html#a31fc2694189aacb9b1f55a1664661b84">storeTransactions</a> (const std::vector&lt; Types::Trytes &gt; &amp;trytes) const</td></tr>
<tr class="separator:a31fc2694189aacb9b1f55a1664661b84 inherit pub_methods_class_i_o_t_a_1_1_a_p_i_1_1_core"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_extended.html">Extended</a> API calls which will help do just about anything possible with IOTA. These are mostly wrapper functions of <a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_core.html">Core</a> API calls. <a href="https://github.com/iotaledger/wiki/blob/master/api-proposal.md#proposed-api-calls">https://github.com/iotaledger/wiki/blob/master/api-proposal.md#proposed-api-calls</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a24292e0b13d2bfe35584f733c322b8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24292e0b13d2bfe35584f733c322b8c9">&#9670;&nbsp;</a></span>Extended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IOTA::API::Extended::Extended </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localPow</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>60</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Crypto::SpongeType&#160;</td>
          <td class="paramname"><em>cryptoType</em> = <code>Crypto::SpongeType::KERL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full init ctor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host of the node to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port of the node to connect to. </td></tr>
    <tr><td class="paramname">localPow</td><td>Whether to do local or remote proof of work. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout for the requests. </td></tr>
    <tr><td class="paramname">cryptoType</td><td>Type of cryptographic algorithm to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae292873ec0cd8936d28e7ffe95cb6c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae292873ec0cd8936d28e7ffe95cb6c83">&#9670;&nbsp;</a></span>~Extended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IOTA::API::Extended::~Extended </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default dtor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a622593ef0532f94e695bcb88b3f9fc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622593ef0532f94e695bcb88b3f9fc7e">&#9670;&nbsp;</a></span>addRemainder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Types::Trytes&gt; IOTA::API::Extended::addRemainder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_tag.html">Models::Tag</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>totalValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>signatureFragments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">inputs</td><td>List of inputs used for funding the transfer. </td></tr>
    <tr><td class="paramname">bundle</td><td>To be populated. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag </td></tr>
    <tr><td class="paramname">totalValue</td><td>The total value. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to. </td></tr>
    <tr><td class="paramname">signatureFragments</td><td>The signature fragments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of trytes. </dd></dl>

</div>
</div>
<a id="aa84894cbaa3fa57252a8a34a75e0d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84894cbaa3fa57252a8a34a75e0d7ab">&#9670;&nbsp;</a></span>broadcastAndStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_base.html">Responses::Base</a> IOTA::API::Extended::broadcastAndStore </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that does broadcastTransactions and storeTransactions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trytes</td><td>Trytes to be broadcasted and stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The response. </dd></dl>

</div>
</div>
<a id="aa4c0d93b663159c9aeadce499279dd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c0d93b663159c9aeadce499279dd2c">&#9670;&nbsp;</a></span>bundlesFromAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a>&gt; IOTA::API::Extended::bundlesFromAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>function to get the formatted bundles of a list of addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>List of addresses. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bundles </dd></dl>

</div>
</div>
<a id="a84744f17dd0c8f5b8b26062aff52d473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84744f17dd0c8f5b8b26062aff52d473">&#9670;&nbsp;</a></span>findTailTransactionHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Types::Trytes IOTA::API::Extended::findTailTransactionHash </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>hash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of a transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash of the tail transaction of the bundle to which the input trx belongs or EmptyHash </dd></dl>

</div>
</div>
<a id="a4801d5265fa22b702a6c5061073e741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4801d5265fa22b702a6c5061073e741a">&#9670;&nbsp;</a></span>findTransactionObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a>&gt; IOTA::API::Extended::findTransactionObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup transactions for given addresses and return a list of transaction objects</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>Addresses for which transactions objects should be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>

</div>
</div>
<a id="a29595b796aadfef15e95c7e3105b7254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29595b796aadfef15e95c7e3105b7254">&#9670;&nbsp;</a></span>findTransactionObjectsByBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a>&gt; IOTA::API::Extended::findTransactionObjectsByBundle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as findTransactionObjects, but based on bundle hash</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Bundle hashes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions. </dd></dl>

</div>
</div>
<a id="a1386ef7e950e762742dca102cc09e3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1386ef7e950e762742dca102cc09e3b9">&#9670;&nbsp;</a></span>findTransactionsByAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByAddresses </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>The list of addresses.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which have the specified address as an input/output field. </dd></dl>

</div>
</div>
<a id="a93356e4fafc265bb4e3974c9ed74f521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93356e4fafc265bb4e3974c9ed74f521">&#9670;&nbsp;</a></span>findTransactionsByApprovees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByApprovees </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>approvees</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified approvees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">approvees</td><td>The list of approvees of a transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transaction which reference (i.e. confirm) the specified transactions. </dd></dl>

</div>
</div>
<a id="a51c3e80e5cd620fbeaf43a854b68a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c3e80e5cd620fbeaf43a854b68a674">&#9670;&nbsp;</a></span>findTransactionsByBundles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByBundles </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>bundles</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified bundles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bundles</td><td>The list of bundle hashes that need to be extended to 81 chars by padding the hash with 9's.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which contain the specified bundle hash. </dd></dl>

</div>
</div>
<a id="a72f943cddf154a2d7937f2db5f86ee56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f943cddf154a2d7937f2db5f86ee56">&#9670;&nbsp;</a></span>findTransactionsByTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_find_transactions.html">Responses::FindTransactions</a> IOTA::API::Extended::findTransactionsByTags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_tag.html">Models::Tag</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the transactions which match the specified tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tags</td><td>The list of transaction tags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of transactions which contain the specified tag value. </dd></dl>

</div>
</div>
<a id="a64bb1bd334481e0c17457c4f15950168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bb1bd334481e0c17457c4f15950168">&#9670;&nbsp;</a></span>getAccountData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_account_data.html">Responses::GetAccountData</a> IOTA::API::Extended::getAccountData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to getTransfers, just that it returns additional account data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. Default is 0. </td></tr>
    <tr><td class="paramname">security</td><td>The Security level of private key / seed. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. 0 for unlimited </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null). </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. 0 to skip. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. 0 to skip. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required. 0 to skip.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Account data. </dd></dl>

</div>
</div>
<a id="a93ab589f43b642bb197b5f689dde045d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ab589f43b642bb197b5f689dde045d">&#9670;&nbsp;</a></span>getBalancesAndFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a> IOTA::API::Extended::getBalancesAndFormat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_utils_1_1_stop_watch.html">Utils::StopWatch</a> &amp;&#160;</td>
          <td class="paramname"><em>stopWatch</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the balances and formats the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addresses</td><td>The addresses. </td></tr>
    <tr><td class="paramname">threshold</td><td>If set to 0, fetch balance for all input addresses. Otherwise, keep fetching until the threshold is reached. If threshold is &gt; 0 and is not reached, Not Enough Balance exception is raised. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">stopWatch</td><td>the stopwatch. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inputs object. </dd></dl>

</div>
</div>
<a id="aae0bbe508888acfe6f97aca3d9e0da86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0bbe508888acfe6f97aca3d9e0da86">&#9670;&nbsp;</a></span>getBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_bundle.html">Responses::GetBundle</a> IOTA::API::Extended::getBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the associated bundle transactions of a single transaction. Does validation of signatures, total sum as well as bundle order. Basically the same as traverseBundle, but with bundle validity check (signature, order, value and hash check).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>Hash of a tail transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of transactions belonging to bundle corresponding to the input trx </dd></dl>

</div>
</div>
<a id="a2d756839d245fe54c0be7f20b3bf1121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d756839d245fe54c0be7f20b3bf1121">&#9670;&nbsp;</a></span>getInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_balances_and_format.html">Responses::GetBalancesAndFormat</a> IOTA::API::Extended::getInputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all possible inputs of a seed and returns them with the total balance. This is either done deterministically (by genearating all addresses until findTransactions is empty and doing getBalances), or by providing a key range to use for searching through.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The Security level of private key / seed. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. </td></tr>
    <tr><td class="paramname">threshold</td><td>Min balance required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inputs. </dd></dl>

</div>
</div>
<a id="ad80dbd20f6efcabe5234fff81bfde6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80dbd20f6efcabe5234fff81bfde6fe">&#9670;&nbsp;</a></span>getLatestInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_inclusion_states.html">Responses::GetInclusionStates</a> IOTA::API::Extended::getLatestInclusion </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function for getNodeInfo and getInclusionStates</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashes</td><td>The hashes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Inclusion state. </dd></dl>

</div>
</div>
<a id="af9ea9ef613cd8f744d3253c8657ffc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea9ef613cd8f744d3253c8657ffc8c">&#9670;&nbsp;</a></span>getNewAddresses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_new_addresses.html">Responses::GetNewAddresses</a> IOTA::API::Extended::getNewAddresses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t &amp;&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>security</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t &amp;&#160;</td>
          <td class="paramname"><em>total</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>returnAll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generates a new address from a seed and returns the remainderAddress. This is either done deterministically, or by providing the index of the new remainderAddress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>Security level to be used for the private key / address. Can be 1, 2 or 3. </td></tr>
    <tr><td class="paramname">index</td><td>Key index to start search from. If the index is provided, the generation of the address is not deterministic. </td></tr>
    <tr><td class="paramname">total</td><td>Total number of addresses to generate. </td></tr>
    <tr><td class="paramname">returnAll</td><td>If <code>true</code>, it returns all addresses which were deterministically generated (until findTransactions returns null).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of strings with the specifed number of addresses. </dd></dl>

</div>
</div>
<a id="af1bf1f658dea8469758c76375a3063f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bf1f658dea8469758c76375a3063f9">&#9670;&nbsp;</a></span>getTransactionsObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a>&gt; IOTA::API::Extended::getTransactionsObjects </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; IOTA::Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trx_hashes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lookup transactions for given transaction hashes and return a list of transaction objects If a specific transaction does not exist, return valid transaction tryte 9-filled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_hashes</td><td>Hashes of the transactions to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transaction objects. </dd></dl>

</div>
</div>
<a id="a6f408547f1e309afd1f27297b54e61d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f408547f1e309afd1f27297b54e61d4">&#9670;&nbsp;</a></span>getTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_get_transfers.html">Responses::GetTransfers</a> IOTA::API::Extended::getTransfers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inclusionStates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the transfers which are associated with a seed. The transfers are determined by either calculating deterministically which addresses were already used, or by providing a list of indexes to get the transfers from.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed. It should be noted that this seed is not transferred. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">start</td><td>Starting key index. </td></tr>
    <tr><td class="paramname">end</td><td>Ending key index. </td></tr>
    <tr><td class="paramname">inclusionStates</td><td>If <code>true</code>, it gets the inclusion states of the transfers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bundle of transfers. </dd></dl>

</div>
</div>
<a id="a8426a72125a659eb1af9431ec0bd1d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8426a72125a659eb1af9431ec0bd1d39">&#9670;&nbsp;</a></span>initiateTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a>&gt; IOTA::API::Extended::initiateTransfer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>securitySum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;&#160;</td>
          <td class="paramname"><em>inputAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remainderAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares transfer by generating the bundle with the corresponding cosigner transactions. Does not contain signatures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">securitySum</td><td>The sum of security levels used by all co-signers. </td></tr>
    <tr><td class="paramname">inputAddress</td><td>Array of input addresses as well as the securitySum. </td></tr>
    <tr><td class="paramname">remainderAddress</td><td>Has to be generated by the cosigners before initiating the transfer, can be null if fully spent. </td></tr>
    <tr><td class="paramname">transfers</td><td>The transfers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bundle of transaction objects. </dd></dl>

</div>
</div>
<a id="a76135229fb4521f9921374c93523de57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76135229fb4521f9921374c93523de57">&#9670;&nbsp;</a></span>prepareTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Types::Trytes&gt; IOTA::API::Extended::prepareTransfers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>validateInputs</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Main purpose of this function is to get an array of transfer objects as input, and then prepare the transfer by generating the correct bundle, as well as choosing and signing the inputs if necessary (if it's a value transfer). The output of this function is an array of the raw transaction data (trytes).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>81-tryte encoded address of recipient. </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">transfers</td><td>Array of transfer objects. </td></tr>
    <tr><td class="paramname">remainder</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to. </td></tr>
    <tr><td class="paramname">inputs</td><td>The inputs. </td></tr>
    <tr><td class="paramname">validateInputs</td><td>Whether or not to validate the balances of the provided inputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns bundle trytes. </dd></dl>

</div>
</div>
<a id="a1ba2e1ee23eea14dd2aa8a1f4b5ee653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba2e1ee23eea14dd2aa8a1f4b5ee653">&#9670;&nbsp;</a></span>replayBundle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_replay_bundle.html">Responses::ReplayBundle</a> IOTA::API::Extended::replayBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>transaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replays a transfer by doing Proof of Work again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transaction</td><td>The transaction. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Analyzed Transaction objects. </dd></dl>

</div>
</div>
<a id="a821080d858d7d982cc169411c3611ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821080d858d7d982cc169411c3611ccc">&#9670;&nbsp;</a></span>sendTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_a_p_i_1_1_responses_1_1_send_transfer.html">Responses::SendTransfer</a> IOTA::API::Extended::sendTransfer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_seed.html">Models::Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>security</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_transfer.html">Models::Transfer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_i_o_t_a_1_1_models_1_1_input.html">Models::Input</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_i_o_t_a_1_1_models_1_1_address.html">Models::Address</a> &amp;&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that basically does prepareTransfers, as well as attachToTangle and finally, it broadcasts and stores the transactions locally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>Tryte-encoded seed </td></tr>
    <tr><td class="paramname">security</td><td>The security level of private key / seed. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude. </td></tr>
    <tr><td class="paramname">transfers</td><td>Array of transfer objects. </td></tr>
    <tr><td class="paramname">inputs</td><td>List of inputs used for funding the transfer. </td></tr>
    <tr><td class="paramname">address</td><td>If defined, this address will be used for sending the remainder value (of the inputs) to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Array of Transaction objects. </dd></dl>

</div>
</div>
<a id="a58a127282d2f4d9e8dff38a74eb70d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a127282d2f4d9e8dff38a74eb70d67">&#9670;&nbsp;</a></span>sendTrytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_i_o_t_a_1_1_models_1_1_transaction.html">Models::Transaction</a>&gt; IOTA::API::Extended::sendTrytes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Types::Trytes &gt; &amp;&#160;</td>
          <td class="paramname"><em>trytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>minWeightMagnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper function that gets transactions to approve, attaches to Tangle, broadcasts and stores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trytes</td><td>The trytes. </td></tr>
    <tr><td class="paramname">depth</td><td>The depth. </td></tr>
    <tr><td class="paramname">minWeightMagnitude</td><td>The minimum weight magnitude.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transactions objects. </dd></dl>

</div>
</div>
<a id="a7b5c4d33e956c0d76f98aa5a7a1c6f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5c4d33e956c0d76f98aa5a7a1c6f8f">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>

</div>
</div>
<a id="a395484ad3ff8c373adb8c981b4f79cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395484ad3ff8c373adb8c981b4f79cd3">&#9670;&nbsp;</a></span>traverseBundle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> IOTA::API::Extended::traverseBundle </td>
          <td>(</td>
          <td class="paramtype">const Types::Trytes &amp;&#160;</td>
          <td class="paramname"><em>trunkTx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types::Trytes&#160;</td>
          <td class="paramname"><em>bundleHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_o_t_a_1_1_models_1_1_bundle.html">Models::Bundle</a> &amp;&#160;</td>
          <td class="paramname"><em>bundle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basically traverse the Bundle by going down the trunkTransactions until the bundle hash of the transaction is no longer the same. In case the input transaction hash is not a tail, we return an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trunkTx</td><td>Hash of a trunk or a tail transaction of a bundle. </td></tr>
    <tr><td class="paramname">bundleHash</td><td>The bundle hash. </td></tr>
    <tr><td class="paramname">bundle</td><td>Bundle to be populated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Filled bundle corresponding to tail transaction. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/iota/api/<a class="el" href="extended_8hpp_source.html">extended.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
